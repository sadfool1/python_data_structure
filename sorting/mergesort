"""
==============================================================================================================================

Merge sort orders a list of values by recursively dividing the list in half until each sub-list has one element recombine.

We will use merge sort without using the inbuilt python merge sort and assume that the elements are all integers

So for the code we have two functions, first your main mergesort(your_list) function that separates the list into two lists, 
Second function merge(tempA, tempB) that reads the first element and compre them.

HOWEVER This code is wrong. As explained below -- refer to line 99 for the write code.

This is because my first attempt

==============================================================================================================================
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Apr 11 17:14:28 2019

@author: jameselijah
"""
import math 

mylist = [3, 4, 2, 1, 9, 8, 10, 2] #test list
tempC =[]

def mergesort(list_sorting):
    if len(list_sorting) == 0:
        print ( list_sorting , "list is empty")
    elif len(list_sorting) == 1:
        print( list_sorting )
    else:
        n = math.ceil(len(list_sorting)/2)
        tempA = [i for i in list_sorting[0:n]] #divide
        tempB = [i for i in list_sorting[n:]]  #divide
        for i in range(1, len(tempA)):  
            temp = tempA[i]
            j = i-1 #iteration before i
            while j >= 0 and temp < tempA[j]: #satisfy both condition
                tempA[j+1] = tempA[j] #
                j -=1 #decrease j counter as we go up the list
            tempA[j+1] = temp
        
        for i in range(1, len(tempB)):
            temp = tempB[i]
            j = i-1 #iteration before i
            while j >= 0 and temp < tempB[j]: #satisfy both condition
                tempB[j+1] = tempB[j] #
                j -=1 #decrease j counter as we go up the list
            tempB[j+1] = temp

        merge(tempA,tempB)

def merge(tempA,tempB):
    indexA = 0
    indexB = 0
    tempC = []
    while (indexA < len(tempA)) or (indexB < len(tempB)):
        if indexA >= len(tempA):
            tempC.append(tempB[indexB])
            indexB +=1
        elif indexB >= len(tempB):
            tempC.append(tempA[indexA])
            indexA +=1
        elif tempA[indexA] > tempB[indexB]:
            tempC.append(tempB[indexB])
            indexB +=1
        else:
            tempC.append(tempA[indexA])
            indexA +=1

    
    print(tempC)

mergesort(mylist)


#Your result should be [1, 2, 2, 3, 4, 8, 9, 10]







"""
==============================================================================================================================

I re-read my notes and found out that my above method is wrong, not the actually the real MergeSort. Below is a piece of code derived from the following

In referrence to B. Miller, D. Ranum. (2014). Created using Runestone 2.7.10. Retrieved from https://interactivepython.org/runestone/static/pythonds/SortSearch/TheMergeSort.html

As submitted to PROF, comments " 2) Insertion node is wrong"

==============================================================================================================================
"""





def mergeSort(mylist):
    if len(mylist)>1:
        n = len(mylist)//2
        tempA = mylist[:n]
        tempB = mylist[n:]
        indexA=0
        indexB=0
        k=0
        
        mergeSort(tempA)
        mergeSort(tempB)

        while indexA < len(tempA) and indexB < len(tempB):
            if tempA[indexA] < tempB[indexB]:
                mylist[k]=tempA[indexA]
                indexA=indexA+1
            else:
                mylist[k]=tempB[indexB]
                indexB=indexB+1
            k=k+1

        while indexA < len(tempA):
            mylist[k]=tempA[indexA]
            indexA=indexA+1
            k=k+1

        while indexB < len(tempB):
            mylist[k]=tempB[indexB]
            indexB=indexB+1
            k=k+1
    elif len(mylist)== 1:
        return mylist
    else:
        print('List empty')
    

mylist = [3,4,2,1,9,8,10,2]
mergeSort(mylist)
print(mylist)


"""
==================================================================================================================
Solution key given by PROF. [to be tested running time]
==================================================================================================================
"""

'''
The following code is contributed by Nikita Tiwari.
It is available at the following webpage: 
https://www.geeksforgeeks.org/maximum-subarray-sum-using-divide-and-conquer-algorithm/ 
''' 

# A Divide and Conquer based program 
# for maximum subarray sum problem 

# Find the maximum possible sum in 
# arr[] auch that arr[m] is part of it 
def maxCrossingSum(arr, l, m, h) : 
	
	# Include elements on left of mid. 
	sm = 0; left_sum = -10000000
	
	for i in range(m, l-1, -1) : 
		sm = sm + arr[i] 
		
		if (sm > left_sum) : 
			left_sum = sm 
	
	
	# Include elements on right of mid 
	sm = 0; right_sum = -1000
	for i in range(m + 1, h + 1) : 
		sm = sm + arr[i] 
		
		if (sm > right_sum) : 
			right_sum = sm 
	

	# Return sum of elements on left and right of mid 
	return left_sum + right_sum; 


# Returns sum of maxium sum subarray in aa[l..h] 
def maxSubArraySum(arr, l, h) : 
	
	# Base Case: Only one element 
	if (l == h) : 
		return arr[l] 

	# Find middle point 
	m = (l + h) // 2

	# Return maximum of following three possible cases 
	# a) Maximum subarray sum in left half 
	# b) Maximum subarray sum in right half 
	# c) Maximum subarray sum such that the 
	#	 subarray crosses the midpoint 
	return max(maxSubArraySum(arr, l, m), 
			maxSubArraySum(arr, m+1, h), 
			maxCrossingSum(arr, l, m, h)) 
			

# Driver Code 
# arr = [2, 3, 4, 5, 7] 
arr = [4,-3,5,-2,-1,2,6,-2]
n = len(arr) 

max_sum = maxSubArraySum(arr, 0, n-1) 
print("Maximum contiguous sum is ", max_sum) 

